<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="$langISO">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <meta name="generator" content="Doxygen 1.9.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.svg">
    <title>RIOT OS: Threading</title>
    <!--BEGIN PROJECT_ICON-->
    <link rel="icon" href="$projecticon" type="image/x-icon" />
    <!--END PROJECT_ICON-->
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <!--BEGIN COPY_CLIPBOARD-->
    <script type="text/javascript" src="clipboard.js"></script>
    <!--END COPY_CLIPBOARD-->
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    $darkmode
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="global.css" rel="stylesheet" type="text/css"/>
    <!-- ... other metadata & script includes ... -->
    <script
      type="text/javascript"
      src="doxygen-awesome-paragraph-link.js"
    ></script>
      <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <!-- <link href="pagefind/pagefind-ui.css" rel="stylesheet"> -->
    <script src="pagefind/pagefind-ui.js"></script>
    <script>
      // Check whether the PagefindUI class is available
      if (typeof PagefindUI === "undefined") {
        console.warn("PagefindUI class is not available | Dev Build");
      } else {
        // // Remove the "searchstub" element and initialize the PagefindUI class
        // document.getElementById("#searchstub").remove();
        // Initialize the PagefindUI class with the element id "search"
        window.addEventListener("DOMContentLoaded", (event) => {
          new PagefindUI({
            element: "#pagefindsearch",
            showSubResults: true,
            showImages: false,
            resetStyles: false,
            mergeFilter: {
              "Information Source": "API Documentation",
            },
            mergeIndex: [{
              bundlePath: "https://riot.annsann.eu/pagefind",
              mergeFilter: {
                "Information Source": "Guides",
              }
          }], 
          });
        });
      }
    </script>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  </head>
  <body>
    <div>
        <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
        <script type="text/javascript">
            DoxygenAwesomeDarkModeToggle.init()
        </script>
          <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
              <tbody>
                <tr id="projectrow">
                  <td id="projectlogo">
                    <img alt="Logo" src="riot-logo.svg" $logosize />
                  </td>
                  <td id="projectalign">
                    <div id="projectname">
                      RIOT OS
                    </div>
                    <div id="projectbrief">The friendly OS for the IoT</div>
                  </td>
                </tr>
                <!--BEGIN FULL_SIDEBAR-->
                <tr>
                  <td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
                </tr>
                <!--END FULL_SIDEBAR-->
              </tbody>
            </table>
            <div
              id="searchbox"
              class="searchboxui"
            >
                <button
                id="enable-search-box"
                class="searchbutton"
                >
                <h3>üê∏üîé</h3>
                <h4>Search</h4>
              </button>
              <div id="pagefindsearch" class="hidden"></div>
            </div>
          </div>
        </div>
        <script>
          /* When the user clicks on the button, toggle between hiding and showing the search box content */
          document.getElementById("enable-search-box").addEventListener("click", function () {
            var searchbox = document.getElementById("pagefindsearch");
            if (searchbox.classList.contains("hidden")) {
              searchbox.classList.remove("hidden");
              /* Focus on the search input field (classname pagefind-ui__search-input) */
              searchbox.querySelector(".pagefind-ui__search-input").focus();
            } else {
              searchbox.classList.add("hidden");
            }
          });
        </script>
        <!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__core__thread.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Threading<div class="ingroups"><a class="el" href="group__core.html">Kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Support for multi-threading. </p>
<h1><a class="anchor" id="autotoc_md18"></a>
Priorities</h1>
<p>As RIOT is using a fixed priority <a class="el" href="group__core__sched.html">scheduling algorithm</a>, threads are scheduled based on their priority. The priority is fixed for every thread and specified during the thread's creation by the <code>priority</code> parameter.</p>
<p>The lower the priority value, the higher the priority of the thread, with 0 being the highest possible priority.</p>
<p>The lowest possible priority is <a class="el" href="thread__config_8h.html#aff75fcd47eeb1872daf68978351983fb">THREAD_PRIORITY_IDLE</a> - 1.</p>
<dl class="section note"><dt>Note</dt><dd>Assigning the same priority to two or more threads is usually not a good idea. A thread in RIOT may run until it yields (<a class="el" href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699">thread_yield</a>) or another thread with higher priority is runnable (<a class="el" href="group__core__sched.html#gaf4e431441709328f9355dfb7e21a0eb9">STATUS_ON_RUNQUEUE</a>) again. Multiple threads with the same priority will therefore be scheduled cooperatively: when one of them is running, all others with the same priority depend on it to yield (or be interrupted by a thread with higher priority). This may make it difficult to determine when which of them gets scheduled and how much CPU time they will get. In most applications, the number of threads in application is significantly smaller than the number of available priorities, so assigning distinct priorities per thread should not be a problem. Only assign the same priority to multiple threads if you know what you are doing!</dd></dl>
<h1><a class="anchor" id="autotoc_md19"></a>
Thread Behavior</h1>
<p>In addition to the priority, flags can be used when creating a thread to alter the thread's behavior after creation. The following flags are available:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Flags   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__core__thread.html#ga31d767ff839598270044e04a53ffa7f4">THREAD_CREATE_SLEEPING</a>   </td><td class="markdownTableBodyNone">the thread will sleep until woken up manually    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="group__core__thread.html#ga55062dd3d2da4ee10c96a5ff39505ff4">THREAD_CREATE_WOUT_YIELD</a>   </td><td class="markdownTableBodyNone">the thread might not run immediately after creation    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="group__core__thread.html#gaca0f981819582216a85af20f6676032b">THREAD_CREATE_NO_STACKTEST</a>   </td><td class="markdownTableBodyNone">never measure the stack's memory usage   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md20"></a>
Thread creation</h1>
<p>Creating a new thread is internally done in two steps:</p><ol type="1">
<li>the new thread's stack is initialized depending on the platform</li>
<li>the new thread is added to the scheduler and the scheduler is run (if not indicated otherwise)</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Creating threads from within an ISR is currently supported, however it is considered to be a bad programming practice and we strongly discourage you from doing so.</dd></dl>
<h2><a class="anchor" id="autotoc_md21"></a>
Usage</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> rcv_thread_stack[<a class="code" href="thread__config_8h.html#a0dc9cf6e8b0b4da823649d78403fff90">THREAD_STACKSIZE_MAIN</a>];</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *rcv_thread(<span class="keywordtype">void</span> *arg)</div>
<div class="line">{</div>
<div class="line">    (void) arg;</div>
<div class="line">    <a class="code" href="structmsg__t.html">msg_t</a> m;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (1) {</div>
<div class="line">        <a class="code" href="group__core__msg.html#gae3e05f08bd71d6f65dc727624c4d5f7a">msg_receive</a>(&amp;m);</div>
<div class="line">        <a class="code" href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2">printf</a>(<span class="stringliteral">&quot;Got msg from %&quot;</span> <a class="code" href="group__core__sched.html#gacbdb91f768b6240701dcb6cfaf0216ac">PRIkernel_pid</a> <span class="stringliteral">&quot;\n&quot;</span>, m.<a class="code" href="structmsg__t.html#a6c7d65a0a86c7b69ed58f9f71a043028">sender_pid</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> NULL;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__core__thread.html#ga7e0403a9aa86ce0ec136f6b069d4434a">thread_create</a>(rcv_thread_stack, <span class="keyword">sizeof</span>(rcv_thread_stack),</div>
<div class="line">                  <a class="code" href="thread__config_8h.html#ac57374d1c51374ebf95d9679281af818">THREAD_PRIORITY_MAIN</a> - 1, 0,</div>
<div class="line">                  rcv_thread, NULL, <span class="stringliteral">&quot;rcv_thread&quot;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__core__msg_html_gae3e05f08bd71d6f65dc727624c4d5f7a"><div class="ttname"><a href="group__core__msg.html#gae3e05f08bd71d6f65dc727624c4d5f7a">msg_receive</a></div><div class="ttdeci">int msg_receive(msg_t *m)</div><div class="ttdoc">Receive a message.</div></div>
<div class="ttc" id="agroup__core__sched_html_gacbdb91f768b6240701dcb6cfaf0216ac"><div class="ttname"><a href="group__core__sched.html#gacbdb91f768b6240701dcb6cfaf0216ac">PRIkernel_pid</a></div><div class="ttdeci">#define PRIkernel_pid</div><div class="ttdoc">Macro for printing formatter.</div><div class="ttdef"><b>Definition:</b> sched.h:125</div></div>
<div class="ttc" id="agroup__core__thread_html_ga7e0403a9aa86ce0ec136f6b069d4434a"><div class="ttname"><a href="group__core__thread.html#ga7e0403a9aa86ce0ec136f6b069d4434a">thread_create</a></div><div class="ttdeci">kernel_pid_t thread_create(char *stack, int stacksize, uint8_t priority, int flags, thread_task_func_t task_func, void *arg, const char *name)</div><div class="ttdoc">Creates a new thread.</div></div>
<div class="ttc" id="agroup__cpu__avr8__common__stdio__wrapper_html_gad2eb277496af160238e7306fff780ad2"><div class="ttname"><a href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2">printf</a></div><div class="ttdeci">#define printf(...)</div><div class="ttdoc">A wrapper for the printf() function that passes arguments through unmodified, but fails to compile if...</div><div class="ttdef"><b>Definition:</b> stdio.h:60</div></div>
<div class="ttc" id="astructmsg__t_html"><div class="ttname"><a href="structmsg__t.html">msg_t</a></div><div class="ttdoc">Describes a message object which can be sent between threads.</div><div class="ttdef"><b>Definition:</b> msg.h:196</div></div>
<div class="ttc" id="astructmsg__t_html_a6c7d65a0a86c7b69ed58f9f71a043028"><div class="ttname"><a href="structmsg__t.html#a6c7d65a0a86c7b69ed58f9f71a043028">msg_t::sender_pid</a></div><div class="ttdeci">kernel_pid_t sender_pid</div><div class="ttdoc">PID of sending thread.</div><div class="ttdef"><b>Definition:</b> msg.h:197</div></div>
<div class="ttc" id="athread__config_8h_html_a0dc9cf6e8b0b4da823649d78403fff90"><div class="ttname"><a href="thread__config_8h.html#a0dc9cf6e8b0b4da823649d78403fff90">THREAD_STACKSIZE_MAIN</a></div><div class="ttdeci">#define THREAD_STACKSIZE_MAIN</div><div class="ttdoc">Size of the main task's stack in bytes.</div><div class="ttdef"><b>Definition:</b> thread_config.h:79</div></div>
<div class="ttc" id="athread__config_8h_html_ac57374d1c51374ebf95d9679281af818"><div class="ttname"><a href="thread__config_8h.html#ac57374d1c51374ebf95d9679281af818">THREAD_PRIORITY_MAIN</a></div><div class="ttdeci">#define THREAD_PRIORITY_MAIN</div><div class="ttdoc">Priority of the main thread.</div><div class="ttdef"><b>Definition:</b> thread_config.h:135</div></div>
</div><!-- fragment --><p>Reading from the top down, you can see that first, stack memory for our thread <code>rcv_thread</code> is preallocated, followed by an implementation of the thread's function. Communication between threads is done using <a class="el" href="group__core__msg.html">Messaging / IPC</a>. In this case, <code>rcv_thread</code> will print the process id of each thread that sent a message to <code>rcv_thread</code>.</p>
<p>After it has been properly defined, <code>rcv_thread</code> is created with a call to <a class="el" href="group__core__thread.html#ga7e0403a9aa86ce0ec136f6b069d4434a">thread_create()</a> in <code>main()</code>. It is assigned a priority of <code>THREAD_PRIORITY_MAIN - 1</code>, i.e. a slightly <em>higher</em> priority than the main thread. Since neither the <code>THREAD_CREATE_SLEEPING</code> nor the <code>THREAD_CREATE_WOUT_YIELD</code> flag is set, <code>rcv_thread</code> will be executed immediately.</p>
<dl class="section note"><dt>Note</dt><dd>If the messages to the thread are sent using <a class="el" href="group__core__msg.html#ga99264bd4f263fa2b478308c1f7983c10">msg_try_send()</a> or from an ISR, activate your thread's message queue by calling <a class="el" href="group__core__msg.html#ga480e6f32c8ab18579b62a890f3fda2cd">msg_init_queue()</a> to prevent messages from being dropped when they can't be handled right away. The same applies if you'd like <a class="el" href="group__core__msg.html#gac5347725c3d203ac72604c0ab8b7d6d8" title="Send a message (blocking).">msg_send()</a> to your thread to be non-blocking. For more details, see <a class="el" href="group__core__msg.html">the Messaging documentation</a>. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:core_2include_2thread_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_2include_2thread_8h.html">thread.h</a></td></tr>
<tr class="memdesc:core_2include_2thread_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threading API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:thread__config_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread__config_8h.html">thread_config.h</a></td></tr>
<tr class="memdesc:thread__config_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structThread.html" title="Thread struct within mqtt paho.">Thread</a> configuration defines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__thread.html">_thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>thread_t</code> holds thread's context data.  <a href="struct__thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae42834449d4aa117dd881cc1716a5f4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gae42834449d4aa117dd881cc1716a5f4e">THREAD_MAYBE_INLINE</a></td></tr>
<tr class="memdesc:gae42834449d4aa117dd881cc1716a5f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro definition to inline some of the platform specific implementations.  <a href="group__core__thread.html#gae42834449d4aa117dd881cc1716a5f4e">More...</a><br /></td></tr>
<tr class="separator:gae42834449d4aa117dd881cc1716a5f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55ed7288e242cd4b2a8872f912dae96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gaa55ed7288e242cd4b2a8872f912dae96">CONFIG_THREAD_NAMES</a></td></tr>
<tr class="memdesc:gaa55ed7288e242cd4b2a8872f912dae96"><td class="mdescLeft">&#160;</td><td class="mdescRight">This global macro enable storage of thread names to help developers.  <a href="group__core__thread.html#gaa55ed7288e242cd4b2a8872f912dae96">More...</a><br /></td></tr>
<tr class="separator:gaa55ed7288e242cd4b2a8872f912dae96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab1b7486500c7dbaabdd2ac9a085ac39a"><td class="memItemLeft" align="right" valign="top"><a id="gab1b7486500c7dbaabdd2ac9a085ac39a"></a>
typedef void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gab1b7486500c7dbaabdd2ac9a085ac39a">thread_task_func_t</a>) (void *arg)</td></tr>
<tr class="memdesc:gab1b7486500c7dbaabdd2ac9a085ac39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype for a thread entry function. <br /></td></tr>
<tr class="separator:gab1b7486500c7dbaabdd2ac9a085ac39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7e0403a9aa86ce0ec136f6b069d4434a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga7e0403a9aa86ce0ec136f6b069d4434a">thread_create</a> (char *stack, int stacksize, uint8_t priority, int flags, <a class="el" href="group__core__thread.html#gab1b7486500c7dbaabdd2ac9a085ac39a">thread_task_func_t</a> task_func, void *arg, const char *name)</td></tr>
<tr class="memdesc:ga7e0403a9aa86ce0ec136f6b069d4434a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new thread.  <a href="group__core__thread.html#ga7e0403a9aa86ce0ec136f6b069d4434a">More...</a><br /></td></tr>
<tr class="separator:ga7e0403a9aa86ce0ec136f6b069d4434a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590ebd6a4db0890f35e9bd03c8d98b74"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga590ebd6a4db0890f35e9bd03c8d98b74">thread_get_unchecked</a> (<a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> pid)</td></tr>
<tr class="memdesc:ga590ebd6a4db0890f35e9bd03c8d98b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a thread control block by PID.  <a href="group__core__thread.html#ga590ebd6a4db0890f35e9bd03c8d98b74">More...</a><br /></td></tr>
<tr class="separator:ga590ebd6a4db0890f35e9bd03c8d98b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga291191901d69837ffff231d312892c70"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga291191901d69837ffff231d312892c70">thread_get</a> (<a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> pid)</td></tr>
<tr class="memdesc:ga291191901d69837ffff231d312892c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a thread control block by PID.  <a href="group__core__thread.html#ga291191901d69837ffff231d312892c70">More...</a><br /></td></tr>
<tr class="separator:ga291191901d69837ffff231d312892c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126920c73220c857489a340ee1a5072a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__sched.html#gac528c02d3cccfb103d539b26ccdba6b2">thread_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga126920c73220c857489a340ee1a5072a">thread_getstatus</a> (<a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> pid)</td></tr>
<tr class="memdesc:ga126920c73220c857489a340ee1a5072a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of a process.  <a href="group__core__thread.html#ga126920c73220c857489a340ee1a5072a">More...</a><br /></td></tr>
<tr class="separator:ga126920c73220c857489a340ee1a5072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d16ab2564e99827b629f8cb1a253beb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga8d16ab2564e99827b629f8cb1a253beb">thread_sleep</a> (void)</td></tr>
<tr class="memdesc:ga8d16ab2564e99827b629f8cb1a253beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the current thread into sleep mode.  <a href="group__core__thread.html#ga8d16ab2564e99827b629f8cb1a253beb">More...</a><br /></td></tr>
<tr class="separator:ga8d16ab2564e99827b629f8cb1a253beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa9229e0f462f60bb9550919fa3d7699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699">thread_yield</a> (void)</td></tr>
<tr class="memdesc:gaaa9229e0f462f60bb9550919fa3d7699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets current thread yield.  <a href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699">More...</a><br /></td></tr>
<tr class="separator:gaaa9229e0f462f60bb9550919fa3d7699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ca2e8c4cc394985e88b643d2a61840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__thread.html#gae42834449d4aa117dd881cc1716a5f4e">THREAD_MAYBE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga83ca2e8c4cc394985e88b643d2a61840">thread_yield_higher</a> (void)</td></tr>
<tr class="memdesc:ga83ca2e8c4cc394985e88b643d2a61840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets current thread yield in favor of a higher prioritized thread.  <a href="group__core__thread.html#ga83ca2e8c4cc394985e88b643d2a61840">More...</a><br /></td></tr>
<tr class="separator:ga83ca2e8c4cc394985e88b643d2a61840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c8b55efc2c693fc6e2c6acd9ca2ddb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga76c8b55efc2c693fc6e2c6acd9ca2ddb">thread_zombify</a> (void)</td></tr>
<tr class="memdesc:ga76c8b55efc2c693fc6e2c6acd9ca2ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the current thread into zombie state.  <a href="group__core__thread.html#ga76c8b55efc2c693fc6e2c6acd9ca2ddb">More...</a><br /></td></tr>
<tr class="separator:ga76c8b55efc2c693fc6e2c6acd9ca2ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga862dec3a65ad85c3b18bdf2d5450880e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga862dec3a65ad85c3b18bdf2d5450880e">thread_kill_zombie</a> (<a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> pid)</td></tr>
<tr class="memdesc:ga862dec3a65ad85c3b18bdf2d5450880e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates zombie thread.  <a href="group__core__thread.html#ga862dec3a65ad85c3b18bdf2d5450880e">More...</a><br /></td></tr>
<tr class="separator:ga862dec3a65ad85c3b18bdf2d5450880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab65867d92604d57f6efb622586466f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gaab65867d92604d57f6efb622586466f4">thread_wakeup</a> (<a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> pid)</td></tr>
<tr class="memdesc:gaab65867d92604d57f6efb622586466f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakes up a sleeping thread.  <a href="group__core__thread.html#gaab65867d92604d57f6efb622586466f4">More...</a><br /></td></tr>
<tr class="separator:gaab65867d92604d57f6efb622586466f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab68e945fba9216126e255648a9a4ee8a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gab68e945fba9216126e255648a9a4ee8a">thread_getpid</a> (void)</td></tr>
<tr class="memdesc:gab68e945fba9216126e255648a9a4ee8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the process ID of the currently running thread.  <a href="group__core__thread.html#gab68e945fba9216126e255648a9a4ee8a">More...</a><br /></td></tr>
<tr class="separator:gab68e945fba9216126e255648a9a4ee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga605ef75cf40c9116339ba8ef54193e4c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga605ef75cf40c9116339ba8ef54193e4c">thread_get_active</a> (void)</td></tr>
<tr class="memdesc:ga605ef75cf40c9116339ba8ef54193e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the <a class="el" href="structThread.html" title="Thread struct within mqtt paho.">Thread</a> Control Block of the currently running thread.  <a href="group__core__thread.html#ga605ef75cf40c9116339ba8ef54193e4c">More...</a><br /></td></tr>
<tr class="separator:ga605ef75cf40c9116339ba8ef54193e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46cf14bb228358de0e8a7a0e5425a466"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga46cf14bb228358de0e8a7a0e5425a466">thread_stack_init</a> (<a class="el" href="group__core__thread.html#gab1b7486500c7dbaabdd2ac9a085ac39a">thread_task_func_t</a> task_func, void *arg, void *stack_start, int stack_size)</td></tr>
<tr class="memdesc:ga46cf14bb228358de0e8a7a0e5425a466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets called upon thread creation to set CPU registers.  <a href="group__core__thread.html#ga46cf14bb228358de0e8a7a0e5425a466">More...</a><br /></td></tr>
<tr class="separator:ga46cf14bb228358de0e8a7a0e5425a466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b51382807f0a214c15e282fec5476f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga66b51382807f0a214c15e282fec5476f">thread_add_to_list</a> (<a class="el" href="list_8h.html#a865bd3b3cd44b1d8f1d63746748fa807">list_node_t</a> *list, <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *thread)</td></tr>
<tr class="memdesc:ga66b51382807f0a214c15e282fec5476f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add thread to list, sorted by priority (internal)  <a href="group__core__thread.html#ga66b51382807f0a214c15e282fec5476f">More...</a><br /></td></tr>
<tr class="separator:ga66b51382807f0a214c15e282fec5476f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95be7fb4afdce288dd85286c8591c8dd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga95be7fb4afdce288dd85286c8591c8dd">thread_getname</a> (<a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> pid)</td></tr>
<tr class="memdesc:ga95be7fb4afdce288dd85286c8591c8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of a process.  <a href="group__core__thread.html#ga95be7fb4afdce288dd85286c8591c8dd">More...</a><br /></td></tr>
<tr class="separator:ga95be7fb4afdce288dd85286c8591c8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f434687135c31e82dedd44da4bc0f92"><td class="memItemLeft" align="right" valign="top"><a id="ga0f434687135c31e82dedd44da4bc0f92"></a>
uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga0f434687135c31e82dedd44da4bc0f92">measure_stack_free_internal</a> (const char *stack, size_t size)</td></tr>
<tr class="memdesc:ga0f434687135c31e82dedd44da4bc0f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the stack usage of a stack. <br /></td></tr>
<tr class="separator:ga0f434687135c31e82dedd44da4bc0f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb6763813ca04ff4b87b47f3d524505b"><td class="memItemLeft" align="right" valign="top"><a id="gabb6763813ca04ff4b87b47f3d524505b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gabb6763813ca04ff4b87b47f3d524505b">thread_isr_stack_usage</a> (void)</td></tr>
<tr class="memdesc:gabb6763813ca04ff4b87b47f3d524505b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes used on the ISR stack. <br /></td></tr>
<tr class="separator:gabb6763813ca04ff4b87b47f3d524505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ce2b0b9af6fd608f8135076aeaff674"><td class="memItemLeft" align="right" valign="top"><a id="ga7ce2b0b9af6fd608f8135076aeaff674"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga7ce2b0b9af6fd608f8135076aeaff674">thread_isr_stack_pointer</a> (void)</td></tr>
<tr class="memdesc:ga7ce2b0b9af6fd608f8135076aeaff674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current ISR stack pointer. <br /></td></tr>
<tr class="separator:ga7ce2b0b9af6fd608f8135076aeaff674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fd6618f65f13fd9a023b79da69545b1"><td class="memItemLeft" align="right" valign="top"><a id="ga7fd6618f65f13fd9a023b79da69545b1"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga7fd6618f65f13fd9a023b79da69545b1">thread_isr_stack_start</a> (void)</td></tr>
<tr class="memdesc:ga7fd6618f65f13fd9a023b79da69545b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the start of the ISR stack. <br /></td></tr>
<tr class="separator:ga7fd6618f65f13fd9a023b79da69545b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05ea0c25c648d6990819d8502ae47696"><td class="memItemLeft" align="right" valign="top"><a id="ga05ea0c25c648d6990819d8502ae47696"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga05ea0c25c648d6990819d8502ae47696">thread_stack_print</a> (void)</td></tr>
<tr class="memdesc:ga05ea0c25c648d6990819d8502ae47696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the current stack to stdout. <br /></td></tr>
<tr class="separator:ga05ea0c25c648d6990819d8502ae47696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad80df800e5bde287544899ebea3af1c9"><td class="memItemLeft" align="right" valign="top"><a id="gad80df800e5bde287544899ebea3af1c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gad80df800e5bde287544899ebea3af1c9">thread_print_stack</a> (void)</td></tr>
<tr class="memdesc:gad80df800e5bde287544899ebea3af1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints human readable, ps-like thread information for debugging purposes. <br /></td></tr>
<tr class="separator:gad80df800e5bde287544899ebea3af1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d49bed9a012215e798f4ec4027bd4cd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga7d49bed9a012215e798f4ec4027bd4cd">thread_has_msg_queue</a> (const volatile struct <a class="el" href="struct__thread.html">_thread</a> *thread)</td></tr>
<tr class="memdesc:ga7d49bed9a012215e798f4ec4027bd4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a thread has an initialized message queue.  <a href="group__core__thread.html#ga7d49bed9a012215e798f4ec4027bd4cd">More...</a><br /></td></tr>
<tr class="separator:ga7d49bed9a012215e798f4ec4027bd4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc7668e26f5270824c18641cb3cbf802"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__core__sched.html#gac528c02d3cccfb103d539b26ccdba6b2">thread_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gabc7668e26f5270824c18641cb3cbf802">thread_get_status</a> (const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *thread)</td></tr>
<tr class="memdesc:gabc7668e26f5270824c18641cb3cbf802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread's status.  <a href="group__core__thread.html#gabc7668e26f5270824c18641cb3cbf802">More...</a><br /></td></tr>
<tr class="separator:gabc7668e26f5270824c18641cb3cbf802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2793dad289626600e20c24136d788d94"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga2793dad289626600e20c24136d788d94">thread_get_priority</a> (const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *thread)</td></tr>
<tr class="memdesc:ga2793dad289626600e20c24136d788d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread's priority.  <a href="group__core__thread.html#ga2793dad289626600e20c24136d788d94">More...</a><br /></td></tr>
<tr class="separator:ga2793dad289626600e20c24136d788d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7beb106598f0c575c227cf8ed0476a0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gab7beb106598f0c575c227cf8ed0476a0">thread_is_active</a> (const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *thread)</td></tr>
<tr class="memdesc:gab7beb106598f0c575c227cf8ed0476a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if a thread is active (currently running or waiting to be scheduled)  <a href="group__core__thread.html#gab7beb106598f0c575c227cf8ed0476a0">More...</a><br /></td></tr>
<tr class="separator:gab7beb106598f0c575c227cf8ed0476a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4facacad3d8f92317d1441b779c06147"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga4facacad3d8f92317d1441b779c06147">thread_state_to_string</a> (<a class="el" href="group__core__sched.html#gac528c02d3cccfb103d539b26ccdba6b2">thread_status_t</a> state)</td></tr>
<tr class="memdesc:ga4facacad3d8f92317d1441b779c06147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a thread state code to a human readable string.  <a href="group__core__thread.html#ga4facacad3d8f92317d1441b779c06147">More...</a><br /></td></tr>
<tr class="separator:ga4facacad3d8f92317d1441b779c06147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2729868906246ee7d10f39248e6b38b"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gad2729868906246ee7d10f39248e6b38b">thread_get_stackstart</a> (const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *thread)</td></tr>
<tr class="memdesc:gad2729868906246ee7d10f39248e6b38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get start address (lowest) of a thread's stack.  <a href="group__core__thread.html#gad2729868906246ee7d10f39248e6b38b">More...</a><br /></td></tr>
<tr class="separator:gad2729868906246ee7d10f39248e6b38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1840b02a7834a147ed07be206e05020"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gab1840b02a7834a147ed07be206e05020">thread_get_sp</a> (const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *thread)</td></tr>
<tr class="memdesc:gab1840b02a7834a147ed07be206e05020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stored Stack Pointer of thread.  <a href="group__core__thread.html#gab1840b02a7834a147ed07be206e05020">More...</a><br /></td></tr>
<tr class="separator:gab1840b02a7834a147ed07be206e05020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3023b920b107656efd152a31a5cd9983"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga3023b920b107656efd152a31a5cd9983">thread_get_stacksize</a> (const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *thread)</td></tr>
<tr class="memdesc:ga3023b920b107656efd152a31a5cd9983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of a thread's stack.  <a href="group__core__thread.html#ga3023b920b107656efd152a31a5cd9983">More...</a><br /></td></tr>
<tr class="separator:ga3023b920b107656efd152a31a5cd9983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf75328abc29a0c004cfe6f1f1f010e9e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gaf75328abc29a0c004cfe6f1f1f010e9e">thread_getpid_of</a> (const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *thread)</td></tr>
<tr class="memdesc:gaf75328abc29a0c004cfe6f1f1f010e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get PID of thread.  <a href="group__core__thread.html#gaf75328abc29a0c004cfe6f1f1f010e9e">More...</a><br /></td></tr>
<tr class="separator:gaf75328abc29a0c004cfe6f1f1f010e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga705b23a68178d07032091a81b5e0f7b0"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga705b23a68178d07032091a81b5e0f7b0">thread_get_name</a> (const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *thread)</td></tr>
<tr class="memdesc:ga705b23a68178d07032091a81b5e0f7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of thread.  <a href="group__core__thread.html#ga705b23a68178d07032091a81b5e0f7b0">More...</a><br /></td></tr>
<tr class="separator:ga705b23a68178d07032091a81b5e0f7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e445472b5a25b211079bb3e2d552c77"><td class="memItemLeft" align="right" valign="top">static uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga6e445472b5a25b211079bb3e2d552c77">thread_measure_stack_free</a> (const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *thread)</td></tr>
<tr class="memdesc:ga6e445472b5a25b211079bb3e2d552c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the stack usage of a stack.  <a href="group__core__thread.html#ga6e445472b5a25b211079bb3e2d552c77">More...</a><br /></td></tr>
<tr class="separator:ga6e445472b5a25b211079bb3e2d552c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Optional flags for controlling a threads initial state</h2></td></tr>
<tr class="memitem:ga31d767ff839598270044e04a53ffa7f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga31d767ff839598270044e04a53ffa7f4">THREAD_CREATE_SLEEPING</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:ga31d767ff839598270044e04a53ffa7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the new thread to sleeping.  <a href="group__core__thread.html#ga31d767ff839598270044e04a53ffa7f4">More...</a><br /></td></tr>
<tr class="separator:ga31d767ff839598270044e04a53ffa7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8901763d4bd30418a4ef730711b86ae"><td class="memItemLeft" align="right" valign="top"><a id="gaa8901763d4bd30418a4ef730711b86ae"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gaa8901763d4bd30418a4ef730711b86ae">THREAD_AUTO_FREE</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:gaa8901763d4bd30418a4ef730711b86ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently not implemented. <br /></td></tr>
<tr class="separator:gaa8901763d4bd30418a4ef730711b86ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55062dd3d2da4ee10c96a5ff39505ff4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga55062dd3d2da4ee10c96a5ff39505ff4">THREAD_CREATE_WOUT_YIELD</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:ga55062dd3d2da4ee10c96a5ff39505ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not automatically call <a class="el" href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699" title="Lets current thread yield.">thread_yield()</a> after creation: the newly created thread might not run immediately.  <a href="group__core__thread.html#ga55062dd3d2da4ee10c96a5ff39505ff4">More...</a><br /></td></tr>
<tr class="separator:ga55062dd3d2da4ee10c96a5ff39505ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0f981819582216a85af20f6676032b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#gaca0f981819582216a85af20f6676032b">THREAD_CREATE_NO_STACKTEST</a>&#160;&#160;&#160;(8)</td></tr>
<tr class="memdesc:gaca0f981819582216a85af20f6676032b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Never write markers into the thread's stack to measure stack usage.  <a href="group__core__thread.html#gaca0f981819582216a85af20f6676032b">More...</a><br /></td></tr>
<tr class="separator:gaca0f981819582216a85af20f6676032b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f8182fbb138fd27746e509b69d3aed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__thread.html#ga51f8182fbb138fd27746e509b69d3aed">THREAD_CREATE_STACKTEST</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga51f8182fbb138fd27746e509b69d3aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy flag kept for compatibility.  <a href="group__core__thread.html#ga51f8182fbb138fd27746e509b69d3aed">More...</a><br /></td></tr>
<tr class="separator:ga51f8182fbb138fd27746e509b69d3aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa55ed7288e242cd4b2a8872f912dae96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa55ed7288e242cd4b2a8872f912dae96">&#9670;&nbsp;</a></span>CONFIG_THREAD_NAMES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_THREAD_NAMES</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This global macro enable storage of thread names to help developers. </p>
<pre class="fragment">     To activate it set environment variable `THREAD_NAMES=1`, or use Kconfig.
     It is automatically enabled if `DEVELHELP` is.
</pre> 
</div>
</div>
<a id="gaca0f981819582216a85af20f6676032b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca0f981819582216a85af20f6676032b">&#9670;&nbsp;</a></span>THREAD_CREATE_NO_STACKTEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_CREATE_NO_STACKTEST&#160;&#160;&#160;(8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Never write markers into the thread's stack to measure stack usage. </p>
<p>This flag is ignored when DEVELHELP or SCHED_TEST_STACK is not enabled </p>

</div>
</div>
<a id="ga31d767ff839598270044e04a53ffa7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31d767ff839598270044e04a53ffa7f4">&#9670;&nbsp;</a></span>THREAD_CREATE_SLEEPING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_CREATE_SLEEPING&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the new thread to sleeping. </p>
<p>It must be woken up manually. </p>

</div>
</div>
<a id="ga51f8182fbb138fd27746e509b69d3aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51f8182fbb138fd27746e509b69d3aed">&#9670;&nbsp;</a></span>THREAD_CREATE_STACKTEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_CREATE_STACKTEST&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legacy flag kept for compatibility. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>will be removed after 2025.07 release</dd></dl>
<p>This is always enabled with <code>DEVELHELP=1</code> or <code>SCHED_TEST_STACK</code>. </p>

</div>
</div>
<a id="ga55062dd3d2da4ee10c96a5ff39505ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55062dd3d2da4ee10c96a5ff39505ff4">&#9670;&nbsp;</a></span>THREAD_CREATE_WOUT_YIELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_CREATE_WOUT_YIELD&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not automatically call <a class="el" href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699" title="Lets current thread yield.">thread_yield()</a> after creation: the newly created thread might not run immediately. </p>
<p>Purely for optimization. Any other context switch (i.e. an interrupt) can still start the thread at any time! </p>

</div>
</div>
<a id="gae42834449d4aa117dd881cc1716a5f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae42834449d4aa117dd881cc1716a5f4e">&#9670;&nbsp;</a></span>THREAD_MAYBE_INLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_MAYBE_INLINE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro definition to inline some of the platform specific implementations. </p>
<p>Should be enabled when advantageous by CPU's in their thread_arch.h header </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga66b51382807f0a214c15e282fec5476f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66b51382807f0a214c15e282fec5476f">&#9670;&nbsp;</a></span>thread_add_to_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_add_to_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="list_8h.html#a865bd3b3cd44b1d8f1d63746748fa807">list_node_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add thread to list, sorted by priority (internal) </p>
<p>This will add <code>thread</code> to <code>list</code> sorted by the thread priority. It reuses the thread's rq_entry field. Used internally by msg and mutex implementations.</p>
<dl class="section note"><dt>Note</dt><dd>Only use for threads <em>not on any runqueue</em> and with interrupts disabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>ptr to list root node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>thread to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e0403a9aa86ce0ec136f6b069d4434a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e0403a9aa86ce0ec136f6b069d4434a">&#9670;&nbsp;</a></span>thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> thread_create </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stacksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__thread.html#gab1b7486500c7dbaabdd2ac9a085ac39a">thread_task_func_t</a>&#160;</td>
          <td class="paramname"><em>task_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new thread. </p>
<p>For an in-depth discussion of thread priorities, behavior and and flags, see <a class="el" href="group__core__thread.html">Threading</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Avoid assigning the same priority to two or more threads. </dd>
<dd>
Creating threads from within an ISR is currently supported, however it is considered to be a bad programming practice and we strongly discourage you from doing so.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stack</td><td>start address of the preallocated stack memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stacksize</td><td>the size of the thread's stack in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>priority of the new thread, lower mean higher priority </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>optional flags for the creation of the new thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task_func</td><td>pointer to the code that is executed in the new thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>the argument to the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>a human readable descriptor for the thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PID of newly created task on success </dd>
<dd>
-EINVAL, if <code>priority</code> is greater than or equal to <a class="el" href="group__core__sched.html#ga1868da7c35ae4ff66fc899793d283dd6">SCHED_PRIO_LEVELS</a> </dd>
<dd>
-EOVERFLOW, if there are too many threads running already </dd></dl>

</div>
</div>
<a id="ga291191901d69837ffff231d312892c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga291191901d69837ffff231d312892c70">&#9670;&nbsp;</a></span>thread_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a>* thread_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a thread control block by PID. </p>
<p>This is a bound-checked variant of accessing <code>sched_threads[pid]</code> directly. If you know that the PID is valid, then don't use this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td><a class="el" href="structThread.html" title="Thread struct within mqtt paho.">Thread</a> to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code> if the PID is invalid or there is no such thread. </dd></dl>

</div>
</div>
<a id="ga605ef75cf40c9116339ba8ef54193e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga605ef75cf40c9116339ba8ef54193e4c">&#9670;&nbsp;</a></span>thread_get_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a>* thread_get_active </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the <a class="el" href="structThread.html" title="Thread struct within mqtt paho.">Thread</a> Control Block of the currently running thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the TCB of the currently running thread, or <code>NULL</code> if no thread is running </dd></dl>

</div>
</div>
<a id="ga705b23a68178d07032091a81b5e0f7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga705b23a68178d07032091a81b5e0f7b0">&#9670;&nbsp;</a></span>thread_get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* thread_get_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get name of thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>thread to work on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>thread name or NULL if not available </dd></dl>

</div>
</div>
<a id="ga2793dad289626600e20c24136d788d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2793dad289626600e20c24136d788d94">&#9670;&nbsp;</a></span>thread_get_priority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t thread_get_priority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a thread's priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>thread to work on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>priority of thread </dd></dl>

</div>
</div>
<a id="gab1840b02a7834a147ed07be206e05020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1840b02a7834a147ed07be206e05020">&#9670;&nbsp;</a></span>thread_get_sp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* thread_get_sp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get stored Stack Pointer of thread. </p>
<p><em>Only provides meaningful value if the thread is not currently running!</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>thread to work on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>current stack pointer </dd></dl>

</div>
</div>
<a id="ga3023b920b107656efd152a31a5cd9983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3023b920b107656efd152a31a5cd9983">&#9670;&nbsp;</a></span>thread_get_stacksize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t thread_get_stacksize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get size of a thread's stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>thread to work on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>thread stack size, or 0 if not available </dd></dl>

</div>
</div>
<a id="gad2729868906246ee7d10f39248e6b38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2729868906246ee7d10f39248e6b38b">&#9670;&nbsp;</a></span>thread_get_stackstart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* thread_get_stackstart </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get start address (lowest) of a thread's stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>thread to work on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>current stack pointer, or NULL if not available </dd></dl>

</div>
</div>
<a id="gabc7668e26f5270824c18641cb3cbf802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc7668e26f5270824c18641cb3cbf802">&#9670;&nbsp;</a></span>thread_get_status()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__core__sched.html#gac528c02d3cccfb103d539b26ccdba6b2">thread_status_t</a> thread_get_status </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a thread's status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>thread to work on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of thread </dd></dl>

</div>
</div>
<a id="ga590ebd6a4db0890f35e9bd03c8d98b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga590ebd6a4db0890f35e9bd03c8d98b74">&#9670;&nbsp;</a></span>thread_get_unchecked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a>* thread_get_unchecked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a thread control block by PID. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>pid</code> is valid </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td><a class="el" href="structThread.html" title="Thread struct within mqtt paho.">Thread</a> to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code> if the PID is invalid or there is no such thread. </dd></dl>

</div>
</div>
<a id="ga95be7fb4afdce288dd85286c8591c8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95be7fb4afdce288dd85286c8591c8dd">&#9670;&nbsp;</a></span>thread_getname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* thread_getname </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of a process. </p>
<dl class="section note"><dt>Note</dt><dd>when compiling without DEVELHELP, this <em>always</em> returns NULL!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>the PID of the thread to get the name from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the threads name </dd>
<dd>
<code>NULL</code> if pid is unknown </dd></dl>

</div>
</div>
<a id="gab68e945fba9216126e255648a9a4ee8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab68e945fba9216126e255648a9a4ee8a">&#9670;&nbsp;</a></span>thread_getpid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> thread_getpid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the process ID of the currently running thread. </p>
<dl class="section return"><dt>Returns</dt><dd>obviously you are not a golfer. </dd></dl>

</div>
</div>
<a id="gaf75328abc29a0c004cfe6f1f1f010e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf75328abc29a0c004cfe6f1f1f010e9e">&#9670;&nbsp;</a></span>thread_getpid_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> thread_getpid_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get PID of thread. </p>
<p>This is a simple getter for thread-&gt;pid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>thread to work on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>thread pid </dd></dl>

</div>
</div>
<a id="ga126920c73220c857489a340ee1a5072a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga126920c73220c857489a340ee1a5072a">&#9670;&nbsp;</a></span>thread_getstatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__sched.html#gac528c02d3cccfb103d539b26ccdba6b2">thread_status_t</a> thread_getstatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of a process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>the PID of the thread to get the status from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the thread </dd>
<dd>
<code>STATUS_NOT_FOUND</code> if pid is unknown </dd></dl>

</div>
</div>
<a id="ga7d49bed9a012215e798f4ec4027bd4cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d49bed9a012215e798f4ec4027bd4cd">&#9670;&nbsp;</a></span>thread_has_msg_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int thread_has_msg_queue </td>
          <td>(</td>
          <td class="paramtype">const volatile struct <a class="el" href="struct__thread.html">_thread</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a thread has an initialized message queue. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__msg.html#ga480e6f32c8ab18579b62a890f3fda2cd">msg_init_queue()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The thread to check for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>== 0</code>, if <code>thread</code> has no initialized message queue </dd>
<dd>
<code>!= 0</code>, if <code>thread</code> has its message queue initialized </dd></dl>

</div>
</div>
<a id="gab7beb106598f0c575c227cf8ed0476a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7beb106598f0c575c227cf8ed0476a0">&#9670;&nbsp;</a></span>thread_is_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool thread_is_active </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if a thread is active (currently running or waiting to be scheduled) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>thread to work on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if thread is active, false otherwise </dd></dl>

</div>
</div>
<a id="ga862dec3a65ad85c3b18bdf2d5450880e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga862dec3a65ad85c3b18bdf2d5450880e">&#9670;&nbsp;</a></span>thread_kill_zombie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_kill_zombie </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminates zombie thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>the PID of the thread to terminate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> on success </dd>
<dd>
<code>STATUS_NOT_FOUND</code> if pid is unknown or not a zombie </dd></dl>

</div>
</div>
<a id="ga6e445472b5a25b211079bb3e2d552c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e445472b5a25b211079bb3e2d552c77">&#9670;&nbsp;</a></span>thread_measure_stack_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uintptr_t thread_measure_stack_free </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__sched.html#ga072d60b1771a699e43ff01970e92bb00">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Measures the stack usage of a stack. </p>
<dl class="section pre"><dt>Precondition</dt><dd>Does not work if the thread was created with the flag <code>THREAD_CREATE_NO_STACKTEST</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The thread to measure the stack of</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the amount of unused space of the thread's stack </dd></dl>

</div>
</div>
<a id="ga8d16ab2564e99827b629f8cb1a253beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d16ab2564e99827b629f8cb1a253beb">&#9670;&nbsp;</a></span>thread_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_sleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the current thread into sleep mode. </p>
<p>Has to be woken up externally. </p>

</div>
</div>
<a id="ga46cf14bb228358de0e8a7a0e5425a466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46cf14bb228358de0e8a7a0e5425a466">&#9670;&nbsp;</a></span>thread_stack_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* thread_stack_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__thread.html#gab1b7486500c7dbaabdd2ac9a085ac39a">thread_task_func_t</a>&#160;</td>
          <td class="paramname"><em>task_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stack_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets called upon thread creation to set CPU registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_func</td><td>First function to call within the thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Argument to supply to task_func </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack_start</td><td>Start address of the stack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack_size</td><td>Stack size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stack pointer </dd></dl>

</div>
</div>
<a id="ga4facacad3d8f92317d1441b779c06147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4facacad3d8f92317d1441b779c06147">&#9670;&nbsp;</a></span>thread_state_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* thread_state_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__sched.html#gac528c02d3cccfb103d539b26ccdba6b2">thread_status_t</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a thread state code to a human readable string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>thread state to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ptr to string representation of thread state (or to "unknown") </dd></dl>

</div>
</div>
<a id="gaab65867d92604d57f6efb622586466f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab65867d92604d57f6efb622586466f4">&#9670;&nbsp;</a></span>thread_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int thread_wakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__sched.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wakes up a sleeping thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pid</td><td>the PID of the thread to be woken up</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> on success </dd>
<dd>
<code>STATUS_NOT_FOUND</code> if pid is unknown or not sleeping </dd></dl>

</div>
</div>
<a id="gaaa9229e0f462f60bb9550919fa3d7699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa9229e0f462f60bb9550919fa3d7699">&#9670;&nbsp;</a></span>thread_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lets current thread yield. </p>
<p>The current thread will resume operation immediately, if there is no other ready thread with the same or a higher priority.</p>
<p>Differently from <a class="el" href="group__core__thread.html#ga83ca2e8c4cc394985e88b643d2a61840" title="Lets current thread yield in favor of a higher prioritized thread.">thread_yield_higher()</a> the current thread will be put to the end of the thread's in its priority class.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__thread.html#ga83ca2e8c4cc394985e88b643d2a61840" title="Lets current thread yield in favor of a higher prioritized thread.">thread_yield_higher()</a> </dd></dl>

</div>
</div>
<a id="ga83ca2e8c4cc394985e88b643d2a61840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83ca2e8c4cc394985e88b643d2a61840">&#9670;&nbsp;</a></span>thread_yield_higher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__thread.html#gae42834449d4aa117dd881cc1716a5f4e">THREAD_MAYBE_INLINE</a> void thread_yield_higher </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lets current thread yield in favor of a higher prioritized thread. </p>
<p>The current thread will resume operation immediately, if there is no other ready thread with a higher priority.</p>
<p>Differently from <a class="el" href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699" title="Lets current thread yield.">thread_yield()</a> the current thread will be scheduled next in its own priority class, i.e. it stays the first thread in its priority class.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__core__thread.html#gaaa9229e0f462f60bb9550919fa3d7699" title="Lets current thread yield.">thread_yield()</a> </dd></dl>

</div>
</div>
<a id="ga76c8b55efc2c693fc6e2c6acd9ca2ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76c8b55efc2c693fc6e2c6acd9ca2ddb">&#9670;&nbsp;</a></span>thread_zombify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void thread_zombify </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the current thread into zombie state. </p>
<p>Does nothing when in ISR. A thread in zombie state will never be scheduled again, but its scheduler entry and stack will be kept. A zombie state thread is supposed to be cleaned up by <a class="el" href="group__core__thread.html#ga862dec3a65ad85c3b18bdf2d5450880e">thread_kill_zombie()</a>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<div>
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</div>
</body>
</html>
